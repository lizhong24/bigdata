1、mr程序的效率瓶颈
	功能：分布式离线计算
	计算机性能：CPU、内存、磁盘、网络
	I/O操作优化
	（1）数据倾斜（代码优化）
	（2）map和reduce数设置不合理
	（3）map运行时间太长，导致reduce等待过久
	（4）小文件过多（combineTextInputFomrat小文件合并）
	（5）不可分块的超大文件（不断的溢写）
	（6）多个溢写小文件需要多次merge
2、mr优化方法
	六个方面考虑：数据输入、Map阶段、Reduce阶段、IO传输、
	数据倾斜、参数调优
	1­>数据输入
		（1）合并小文件：在执行mr任务前就进行小文件合并
		（2）采用CombineTextInputFormat来作为输入，解决输 入端大量小文件的场景
		mr并不适合处理大量小文件
	2­>Map阶段
		（1）减少溢写次数（增加内存200M 80%）
		<property>
			<name>mapreduce.task.io.sort.mb</name>
			<value>100</value>
		</property>
		<property>
			<name>mapreduce.map.sort.spill.percent</name>
			<value>0.80</value>
		</property>
		(2)减少合并次数
		<property>
			<name>mapreduce.task.io.sort.factor</name>
			<value>10</value>
		</property>
		（3）在map之后，不影响业务逻辑情况下进行combiner
	3­>Reduce阶段
		（1）合理设置map与reduce个数
		（2）设置map/reduce共存
		设置运行一定程度的map运行后 启动reduce减少等待时间
		<property>
			<name>mapreduce.job.reduce.slowstart.completedmaps</name>
			<value>0.05</value>
		</property>
		（3）合理设置reduce端的buffer
		<property>
			<name>mapreduce.reduce.markreset.buffer.percent</name>
			<value>0.0</value>
		</property>
	4­>传输
		（1）进行数据压缩
		（2）使用sequenceFile
	5­>数据倾斜
		（1）进行范围分区
		（2）自定义分区
		（3）Combine
		(4)能用mapjoin坚决不用reduce join
	6­>参数调优
		设置核心数
		map核心数设置：
		<property>
			<name>mapreduce.map.cpu.vcores</name>
			<value>1</value>
		</property>
		reduce核心数设置：
		<property>
			<name>mapreduce.reduce.cpu.vcores</name>
			<value>1</value>
		</property>
		设置内存
		maptask内存设置：
		<property>
			<name>mapreduce.map.memory.mb</name>
			<value>1024</value>
		</property>
		reducetask内存设置：
		<property>
			<name>mapreduce.reduce.memory.mb</name>
			<value>1024</value>
		</property>
		reduce去map端拿数据并行度
		<property>
			<name>mapreduce.reduce.shuffle.parallelcopies</name>
			<value>5</value>
		</property>